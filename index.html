<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>

  <!--  copied (then adapted) from 'without a bundler' wasm-bindgen example -->
  <script type="module">
    // Use ES module import syntax to import functionality from the module
    // that we have compiled.
    //
    // Note that the `default` import is an initialization function which
    // will "boot" the module and make it ready to use. Currently browsers
    // don't support natively imported WebAssembly as an ES module, but
    // eventually the manual initialization won't be required!
    import init, { ImageApproximation, RGBAImage } from './pkg/lib.js';

    let runningWasm = false

    async function run() {
      // First up we need to actually load the wasm file, so we use the
      // default export to inform it where the wasm file is located on the
      // server, and then we wait on the returned promise to wait for the
      // wasm to be loaded.
      //
      // It may look like this: `await init('./pkg/without_a_bundler_bg.wasm');`,
      // but there is also a handy default inside `init` function, which uses
      // `import.meta` to locate the wasm file relatively to js file.
      //
      // Note that instead of a string you can also pass in any of the
      // following things:
      //
      // * `WebAssembly.Module`
      //
      // * `ArrayBuffer`
      //
      // * `Response`
      //
      // * `Promise` which returns any of the above, e.g. `fetch("./path/to/wasm")`
      //
      // This gives you complete control over how the module is loaded
      // and compiled.
      //
      // Also note that the promise, when resolved, yields the wasm module's
      // exports which is the same as importing the `*_bg` module in other
      // modes
      let bg_module = await init();

      // And afterwards we can use all the functionality defined in wasm.
      return bg_module

    }

    let bg_module = undefined;

    let bg_module_promise = run().then(_bg_module => {
      bg_module = _bg_module;
    });

    let stepper;
    let running = false;

    let defaultImageSrc = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==`
    loadImageUrl(defaultImageSrc)

    function setupWasm() {
      if (bg_module === undefined) {
        console.info("wasm module not loaded yet, self-scheduling for later");
        bg_module_promise.then(setupWasm)
        return
      }

      let imageCanvas = document.querySelector('#canvas-picture')
      let ctx = imageCanvas.getContext("2d")
      window.ctx = ctx;
      let [w, h] = [imageCanvas.width, imageCanvas.height];
      let imageData = ctx.getImageData(0, 0, w, h);
      // window.imageData = imageData;
      let img = RGBAImage.constructor(imageData.data, imageData.width, imageData.height)
      // BEWARE: I didn't use too many references because wasm-bindgen didn't seem to like them. So we are MOVING img here!
      // We get a 'null pointer passed to rust' error if we try to use img later on (in rust, eg by calling img.width()).
      let approx = ImageApproximation.constructor(img, 200000)

      document.querySelector(".js-current-iter").textContent = `${approx.current_iter} - ${approx.previous_error}`;

      stepper = function () {
        console.log('STEPEPR')
        // we want to make sure we don't call `next` until we are done with previous calls. It uses a mutable reference.
        // In rust that wouldn't be allowed, here it would cause a runtime error.
        if (runningWasm) {
          return
        }
        runningWasm = true
        let done = approx.next();
        if (done) {
          running = false;
        }
        let approxData = new Uint8Array(bg_module.memory.buffer, approx.im_result_data_as_pointer(), 4 * w * h);

        // ImageData.data is a UInt8ClampedArray, it has a `set` method
        imageData.data.set(approxData);
        ctx.putImageData(imageData, 0, 0);

        document.querySelector(".js-current-iter").textContent = `${approx.current_iter} - ${approx.previous_error}`;

        runningWasm = false
      };
    }


    // draw an image onto the canvas based on its url.
    function loadImageUrl(src) {
      running = false;
      const img = new Image();
      img.onload = function () {
        let imageCanvas = document.querySelector('#canvas-picture')
        // scale depending on available size.
        const scale = imageCanvas.width / img.naturalWidth;
        imageCanvas.height = img.naturalHeight * scale;
        imageCanvas.getContext("2d").drawImage(img, 0, 0, imageCanvas.width, imageCanvas.height);
        setupWasm();
      };
      img.src = src;
    }

    function fileReceived(f) {
      const reader = new FileReader()
      reader.onload = e => {
        loadImageUrl(e.target.result)
      }
      reader.readAsDataURL(f)
    }


    let input = document.querySelector('#file-upload');
    input.addEventListener('input', (e) => {
      fileReceived(e.currentTarget.files[0])
    })

    // start, step, stop.
    // How do we even?

    // Start: setInterval
    // Stop: clearInterval.
    // Step = stop, and make one call.
    // One more thing is that wasm could be running even if we clearInterval-ed... Think call that takes a long time.
    // In that case we can't call the code. That's a bit annoying. But eh.
    // On new image 'uploaded', stop.

    let startButton = document.querySelector(".js-start");
    let stepButton = document.querySelector(".js-step");
    let stopButton = document.querySelector(".js-stop");
    let resetButton = document.querySelector(".js-reset");

    let stepLoopTimeout;
    function stepLoop() {
      console.log('stepLoop, running', running)
      // we make sure only one loop runs at a time by clearing any existing timeout.
      clearTimeout(stepLoopTimeout);
      if (running) {
        stepper();
        stepLoopTimeout = setTimeout(stepLoop, 1);
      }
    }
    startButton.addEventListener('click', () => {
      running = true;
      stepLoop();
    })

    function stopHandler() {
      console.log('STOP')
      running = false;
    }

    stopButton.addEventListener('click', stopHandler)

    stepButton.addEventListener('click', () => {
      stopHandler();
      stepper();
    })

    resetButton.addEventListener('click', () => {
      stopHandler();
      if (input.value !== '') {
        input.dispatchEvent(new Event('input', { bubbles: true }))
      } else {
        // no file in the input, we want the default
        loadImageUrl(defaultImageSrc)
      }
    })





    </script>


  <style>

      :root {
          --primary: green;
      }
    #canvas-picture {
        border: solid red 1px;
    }


    .button:hover {
        cursor: pointer;
    }

  </style>
</head>
<body>

<button type="button">Browse
  <input id="file-upload" type="file" accept="image/*">
</button>
<canvas id="canvas-picture" width="600" height="600"></canvas>

<div class="buttons">
  <button class="button js-start">Start</button>
  <button class="button js-step">Step</button>
  <button class="button js-stop">Stop</button>
  <button class="button js-reset">Reset</button>
</div>

<div class="infos">
  Current iteration: <span class="js-current-iter"></span>
</div>

</body>
</html>